# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:24:08+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel


class Variation(Enum):
    gsb = 'gsb'
    erzeugung = 'erzeugung'
    eigenstrom = 'eigenstrom'
    co2 = 'co2'
    baeume = 'baeume'


class DispatchLocation(BaseModel):
    energy: Optional[float] = Field(
        None, description='Percentage of energy', examples=[0.2345677]
    )
    location: Optional[Dict[str, Any]] = Field(
        None,
        description='GeoJSON encoded location of target or source of green energy.',
    )


class ForecastItem(BaseModel):
    co2_g_oekostrom: Optional[int] = Field(
        None,
        description='CO2 footprint in Gramm per kwh (only Green Power)',
        examples=[23],
    )
    energyprice: Optional[float] = Field(
        None,
        description='Local/regional energyprice modification (cent per kWh or euro per MWh).',
        examples=[-0.219],
    )
    epochtime: Optional[int] = Field(
        None, description='Timestamps in Seconds', examples=[1609293600]
    )
    gsi: Optional[int] = Field(
        None,
        description='Actual GreenPowerIndex for given Timestamp (between 0-100)',
        examples=[43],
    )
    scaled: Optional[bool] = Field(
        None, description='Indicates if scaling is in operation to predict values'
    )
    sci: Optional[int] = Field(
        None, description='Subindex just for Solar Energy', examples=[43]
    )
    timeStamp: Optional[int] = Field(
        None, description='Timestamp in Standard Milliseconds', examples=[1609293600000]
    )


class MarketData(BaseModel):
    end_timestamp: Optional[int] = Field(
        None, description='Timestamp in Standard Milliseconds', examples=[1609293600000]
    )
    marketprice: Optional[float] = Field(
        None,
        description='Actual Marketprice for regional green power in EUR per MWh',
        examples=[43],
    )
    start_timestamp: Optional[int] = Field(
        None, description='Timestamp in Standard Milliseconds', examples=[1609293600000]
    )


class Tariffh0(BaseModel):
    ap: Optional[int] = Field(
        None,
        description='Energy price in cent per kwh. (Arbeitspreis) including all taxes and fees.',
        examples=[22.12],
    )
    gp: Optional[int] = Field(
        None,
        description='Base price in euro per montah (Grundpreis) including all taxes and fees.',
        examples=[7.5],
    )


class Transactions(BaseModel):
    cashier: Optional[str] = Field(
        None, description='Pretty print of counter signing party', examples=['Miller']
    )
    timeStamp: Optional[int] = Field(
        None,
        description='Cross signed timestamp of transaction',
        examples=[1606777200000],
    )
    txid: Optional[str] = Field(
        None,
        description='Unique hash of this transaction as provided by counter signing party',
        examples=['722d30b2-b46f-4ed4-a8cd-16d262180d37'],
    )
    txtype: Optional[str] = Field(
        None,
        description='Type of transaction per cashier implementation and schema',
        examples=['bank.incGSB'],
    )
    value: Optional[int] = Field(
        None, description='Amount covered by transaction', examples=[1337]
    )


class Componentsh0(BaseModel):
    components: Optional[List[Componentsh0]] = Field(
        None, description='Sub components of this price'
    )
    describtion: Optional[str] = Field(
        None, description='What is this price component about', examples=['Grundgebühr']
    )
    mutlityplier: Optional[str] = Field(
        None, description='Frequency/dependency of component', examples=['month']
    )
    per: Optional[float] = Field(
        None, description='Single unit price multiyplier is based on', examples=[0.012]
    )
    sum: Optional[float] = Field(
        None,
        description='Total sum in Euro for this price component.',
        examples=[22.12],
    )


class EaseeCharger(BaseModel):
    id: Optional[str] = Field(
        None, description='Given ID by easee api', examples=['EH780684']
    )
    lastSession: Optional[str] = Field(
        None, description='lastSession Info as given by easee API'
    )
    name: Optional[str] = Field(None, description='Name set for charger')


class Ommeters(BaseModel):
    currentScalingFactor: Optional[int] = Field(
        None, description='Factor imposed on metered current by a transducer'
    )
    loadProfileType: Optional[str] = Field(
        None, description='Metering load profile type associated with the meter'
    )
    location: Optional[str] = Field(
        None, description='Basic address information for geo coding'
    )
    manufacturerId: Optional[str] = Field(None, description='DLMS manufacturerId')
    measurementType: Optional[str] = Field(
        None, description='Physical quantity being measured by the meter'
    )
    meta: Optional[str] = Field(
        None, description='Statistical metadata for this household'
    )
    meterId: Optional[str] = Field(
        None,
        description='identifier to be used in other methods like readings or activities.',
        examples=[
            'gAAAAABgsYVSfcCjJZV5w2wGBTzOXCihY7dMaDyypwcbJzAELvxeCDaXiy65H2QwtY-7usSOfoqEIomTJjQb1yyIXZfFnTY2pmLgIu_DVw1rjppFte56yWBD5Fgrmbh2KyOkMNUr8zxO'
        ],
    )
    scalingFactor: Optional[int] = Field(
        None,
        description='Factor imposed on metered current AND voltage by a transducer',
    )
    type: Optional[str] = Field(None, description='Device type of the meter')
    voltageScalingFactor: Optional[int] = Field(
        None, description='Factor imposed on metered voltage by a transducer'
    )


class AlternativeEaseeLastSessionsGetResponse(RootModel[List[EaseeCharger]]):
    root: List[EaseeCharger]


class AlternativeOcppLastSessionsGetResponse(RootModel[List[EaseeCharger]]):
    root: List[EaseeCharger]


class AlternativeOpenmeterActivitiesGetResponse(RootModel[List[Ommeters]]):
    root: List[Ommeters]


class AlternativeOpenmeterMetersGetResponse(RootModel[List[Ommeters]]):
    root: List[Ommeters]


class AlternativeOpenmeterReadingsGetResponse(RootModel[List[Ommeters]]):
    root: List[Ommeters]


class Timeframe(BaseModel):
    end: Optional[int] = Field(
        None, description='Ending time of window evaluated for this request/dispatches.'
    )
    start: Optional[int] = Field(
        None, description='Starting time of window evaluated in order to get dispatches'
    )


class GsiDispatchGetResponse(BaseModel):
    avg_distance_km: Optional[float] = Field(
        None,
        description='Averaged geospatial distance in kilometers between energy generation and usage at requested location.',
    )
    dispatch_from: Optional[List[DispatchLocation]] = Field(
        None,
        description='List of current sources of green energy (into requested location)',
    )
    dispatch_target: Optional[List[DispatchLocation]] = Field(
        None,
        description='List of current targets of green energy (out of requested location)',
    )
    postmix: Optional[Dict[str, Any]] = Field(
        None, description='Green Energy Mix after dispatch of given city'
    )
    premix: Optional[Dict[str, Any]] = Field(
        None, description='Green Energy Mix prior to dispatch of given city'
    )
    timeframe: Optional[Timeframe] = Field(
        None, description='Evaluated timeframe for this request'
    )


class GsiMarketdataGetResponse(BaseModel):
    data: Optional[List[MarketData]] = Field(
        None, description='Energyprice for the upcomming hours'
    )


class Location(BaseModel):
    city: Optional[str] = Field(None, description='Pretty Print city name')
    zip: Optional[str] = Field(None, description='Zipcode (Postleitzahl)')


class H0(BaseModel):
    avg_1: Optional[str] = Field(None, description='device should run in 1 hour')
    avg_2: Optional[str] = Field(None, description='device should run in 2 hours')
    avg_3: Optional[str] = Field(None, description='device should run in 3 hour')


class Matrix(BaseModel):
    h0: Optional[H0] = Field(
        None, description='Indicates number of hours a device should run'
    )


class GsiPredictionGetResponse(BaseModel):
    forecast: Optional[List[ForecastItem]] = Field(
        None, description='Prediction for the upcomming hours'
    )
    location: Optional[Location] = Field(
        None, description='Standarized location info sourced for prediction'
    )
    matrix: Optional[Matrix] = Field(
        None, description='Device switching recommendation.'
    )


class MeteringReadingGetResponse(BaseModel):
    field_1_8_0: Optional[int] = Field(
        None, alias='1.8.0', description='Reading as provided as input in Wh'
    )
    field_1_8_1: Optional[int] = Field(
        None,
        alias='1.8.1',
        description='Green energy calculated using Green Power Index (GrünstromIndex) in Wh',
    )
    field_1_8_2: Optional[int] = Field(
        None,
        alias='1.8.2',
        description='Grey energy calculated using Green Power Index (GrünstromIndex) in Wh',
    )
    field_processingTime: Optional[int] = Field(
        None,
        alias='_processingTime',
        description='Time this reading got imported into consensus (e.q. signed timestamp).',
    )
    account: Optional[str] = Field(
        None,
        description='Stromkonto/Metering address allocated (this is not the MELOID!)',
    )
    co2_g_oekostrom: Optional[int] = Field(
        None,
        description='CO2 Emission of metered energy in a green energy mix (e.q. Ökostromtarif)',
    )
    co2_g_standard: Optional[int] = Field(
        None, description='CO2 Emission of metered energy in a standard mix'
    )
    credits: Optional[Any] = Field(
        None,
        description='Update credits this meter has. Gets refilled automtically to prevent too frequent updates',
    )
    timeStamp: Optional[int] = Field(
        None, description='API Consensus time this reading was fully received'
    )
    ttl: Optional[int] = Field(
        None,
        description='Time to Live for this reader. If no update is provided it gets decommissioned.',
    )


class MeteringReadingPostRequest(BaseModel):
    field_1_8_0: Optional[int] = Field(
        None, alias='1.8.0', description='Meter Reading (prefered in Wh)'
    )
    account: Optional[str] = Field(
        None, description='Stromkonto account (address) associated with this metering.'
    )
    energy: Optional[int] = Field(None, description='Alias for 1.8.0')
    secret: Optional[str] = Field(
        None,
        description='Some private password you might choose on first update. However you need to use the same secret on every further posts.',
    )
    value: Optional[int] = Field(None, description='Alias for 1.8.0')
    zip: Optional[str] = Field(
        None, description='Zipcode (Postleitzahl) of metered location'
    )


class MeteringReadingPostResponse(BaseModel):
    field_1_8_0: Optional[int] = Field(
        None, alias='1.8.0', description='Reading as provided as input in Wh'
    )
    field_1_8_1: Optional[int] = Field(
        None,
        alias='1.8.1',
        description='Green energy calculated using Green Power Index (GrünstromIndex) in Wh',
    )
    field_1_8_2: Optional[int] = Field(
        None,
        alias='1.8.2',
        description='Grey energy calculated using Green Power Index (GrünstromIndex) in Wh',
    )
    field_processingTime: Optional[int] = Field(
        None,
        alias='_processingTime',
        description='Time this reading got imported into consensus (e.q. signed timestamp).',
    )
    account: Optional[str] = Field(
        None,
        description='Stromkonto/Metering address allocated (this is not the MELOID!)',
    )
    co2_g_oekostrom: Optional[int] = Field(
        None,
        description='CO2 Emission of metered energy in a green energy mix (e.q. Ökostromtarif)',
    )
    co2_g_standard: Optional[int] = Field(
        None, description='CO2 Emission of metered energy in a standard mix'
    )
    timeStamp: Optional[int] = Field(
        None, description='API Consensus time this reading was fully received'
    )


class QuittungCommitPostRequest(BaseModel):
    account: Optional[str] = None


class QuittungCreatePostRequest(BaseModel):
    email: Optional[str] = None


class QuittungPreparePostRequest(BaseModel):
    account: Optional[str] = None


class QuittungTsePostResponse(BaseModel):
    data: Optional[Any] = Field(None, description='JSON object that got signed by TSE.')
    publickey: Optional[str] = Field(None, description='Public Key of TSE')
    raw: Optional[str] = Field(
        None,
        description='Datastring of JSON Object as it got used to create signature.',
    )
    signature: Optional[str] = Field(
        None,
        description='Resulting signature by signing raw datastring using private key of TSE.',
    )


class StromkontoLoginPostRequest(BaseModel):
    email: Optional[str] = None


class Status(Enum):
    registered = 'registered'
    unregistered = 'unregistered'


class StromkontoLoginPostResponse(BaseModel):
    status: Optional[Status] = Field(
        None,
        description='Registration status of a user. In case unregistered gets returned use the `register` endpoint to (re-)register.',
    )


class StromkontoPrepareTransactionPostRequest(BaseModel):
    account: Optional[str] = Field(
        None, description='Stromkonto account address of sender'
    )
    signature: Optional[str] = Field(
        None,
        description='Signature per Stromkonto setting (might be simple email confirmation link)',
    )
    to: Optional[str] = Field(
        None, description='Stromkonto account address of reciever'
    )
    value: Optional[int] = Field(
        None,
        description='Amount to transfer (in Watthours for electricity, or pcs for trees)',
    )
    variation: Optional[Variation] = None


class StromkontoRegisterPostRequest(BaseModel):
    email: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    zipcode: Optional[str] = None


class TariffSlph0GetResponse(RootModel[List[Tariffh0]]):
    root: List[Tariffh0]


class WimStatusGetResponse(BaseModel):
    wim_started: Optional[int] = Field(
        None, description='Starting time of process', examples=[1615914297977]
    )
    wim_status: Optional[str] = Field(
        None, description='Latest Status', examples=['Erfolgreiche Prüfung']
    )


class Balance(BaseModel):
    balance: Optional[int] = Field(
        None, description='Sum owned - sum due by account', examples=[20]
    )
    haben: Optional[int] = Field(
        None, description='Sum owned by account', examples=[20]
    )
    soll: Optional[int] = Field(None, description='Sum due by account', examples=[20])
    txs: Optional[List[Transactions]] = None
    variation: Optional[Variation] = Field(
        None, description='Type of subbalance (sub account)'
    )


class StromkontoBalancesGetResponse(RootModel[List[Balance]]):
    root: List[Balance]


class StromkontoChoicesGetResponse(RootModel[List[Balance]]):
    root: List[Balance]


Componentsh0.model_rebuild()
