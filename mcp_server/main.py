# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:24:08+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity

from models import (
    AlternativeEaseeLastSessionsGetResponse,
    AlternativeOcppLastSessionsGetResponse,
    AlternativeOpenmeterActivitiesGetResponse,
    AlternativeOpenmeterMetersGetResponse,
    AlternativeOpenmeterReadingsGetResponse,
    Componentsh0,
    GsiDispatchGetResponse,
    GsiMarketdataGetResponse,
    GsiPredictionGetResponse,
    MeteringReadingGetResponse,
    MeteringReadingPostRequest,
    MeteringReadingPostResponse,
    QuittungCommitPostRequest,
    QuittungCreatePostRequest,
    QuittungPreparePostRequest,
    QuittungTsePostResponse,
    StromkontoBalancesGetResponse,
    StromkontoChoicesGetResponse,
    StromkontoLoginPostRequest,
    StromkontoLoginPostResponse,
    StromkontoPrepareTransactionPostRequest,
    StromkontoRegisterPostRequest,
    TariffSlph0GetResponse,
    WimStatusGetResponse,
)

app = MCPProxy(
    contact={'email': 'dev@stromdao.com', 'url': 'https://stromdao.de/kontakt'},
    description='*Corrently - from italian corrente, which is energy*\n# Introduction\nThe Corrently ecosystem gets maintained by [STROMDAO GmbH](https://www.stromdao.de/) to support green energy services for prosumers, grid operators, regulators, integrators or any other party with an emerging need of consensus driven management.\nAs the [energy product Corrently](https://www.corrently.de/) got first launched in Germany parts of this documentation provide simple translations for better understanding.\n[Released SKDs for Download](https://github.com/energychain/corrently-api/releases)\n',
    license={
        'name': 'Apache 2.0',
        'url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
    },
    termsOfService='https://corrently.io/terms/',
    title='Corrently.io',
    version='2.0.0',
    servers=[{'url': 'https://api.corrently.io/v2.0'}],
)


@app.get(
    '/alternative/easee/lastSessions',
    description=""" Refer to easee.cloud API for details.
 """,
    tags=['charging_session_management'],
)
def easee_sessions(username: Optional[str] = None, password: Optional[str] = None):
    """
    Returns lastSession info for all easee wallboxes (chargers) given user has access to.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/alternative/ocpp/lastSessions',
    description=""" Returns lastSession info of OCCP Cloud service for clearing in corrently ecosystem. Might be tested via [OCPP cloud simulator](https://ocpp.corrently.cloud).
Last session Info of managed EV charging stations connected to the correnty ecosystem.
 """,
    tags=['charging_session_management'],
)
def ocpp_sessions():
    """
    Last Session Info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/alternative/openmeter/activities',
    description=""" Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
 """,
    tags=['smart_meter_operations', 'meter_readings_handling'],
)
def om_activities():
    """
    Public shared smart meters installed in Germany and available for subservices and exploration.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/alternative/openmeter/meters',
    description=""" Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
 """,
    tags=['smart_meter_operations', 'meter_readings_handling'],
)
def om_meters():
    """
    Public shared smart meters installed in Germany and available for subservices and exploration.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/alternative/openmeter/readings',
    description=""" Provides a list of available meterrs in the OpenMETER project ( https://www.openmeter.de/ ) which grants access for analytics as data discovery.
 """,
    tags=['smart_meter_operations', 'meter_readings_handling'],
)
def om_readings():
    """
    Public shared smart meters installed in Germany and available for subservices and exploration.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/gsi/bestHour',
    description=""" Simple Wrapper around the GreenPowerIndex for easy integration into almost any SmartHome system that allows access to a JSON/REST Service This endpoint is designed to indicate if a device should be turned on or off. (Switch state).
 """,
    tags=['green_energy_information_services'],
)
def gsi_besthour(
    zip: Optional[str] = None,
    key: Optional[str] = None,
    timeframe: Optional[int] = None,
    hours: Optional[int] = None,
):
    """
    Get best hour (with most regional green energy) in a given timeframe.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/gsi/dispatch',
    description=""" Dispatch of green energy has two aspects to consider:
  - Availability of gerneration facility (depends on weather and installed capacity)
  - Demand of energy
Using the green power index (GrünstromIndex) we have received a tool to automate distribution of energy in order to prevent redispatch situations. Doing this alows to opimize resource usage (tactical) and leverage data for investment planning (strategic).
 """,
    tags=['green_energy_information_services'],
)
def gsi_dispatch(zip: Optional[str] = None, key: Optional[str] = None):
    """
    Dispatch (Green Energy Distribution Schedule)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/gsi/marketdata',
    description=""" Compatible to awattar (https://api.awattar.de/v1/marketdata) API interface but data comes from GreenPowerIndex instead of EPEXSpot.
 """,
    tags=['green_energy_information_services'],
)
def gsi_marketdata(zip: Optional[str] = None):
    """
    Marketdata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/gsi/prediction',
    description=""" Retrieval the GreenPowerIndex (GrünstromIndex) for a given city (by zipcode) in Germany.
 """,
    tags=['green_energy_information_services'],
)
def gsi_prediction(zip: Optional[str] = None, key: Optional[str] = None):
    """
    Prediction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metering/reading',
    description=""" Retrieves a metered reading using account (Stromkonto).
 """,
    tags=['meter_readings_handling', 'smart_meter_operations'],
)
def metering_get(account: Optional[str] = None):
    """
    Meter Reading
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/metering/reading',
    description=""" Post meter reading and get it decorated. Best practice is to first create a new Stromkonto with the register method and choose a nice secret to protect updates. Now regularly send updates to get readings (consumption) split into green power (1.8.1) and grey power (1.8.2).
 """,
    tags=['meter_readings_handling', 'smart_meter_operations'],
)
def metering_post(body: MeteringReadingPostRequest):
    """
    Meter Reading
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/commit',
    description=""" Uses collected fields or provided fields to create a final receipt (Strom-Quittung).
 """,
    tags=['receipt_data_management'],
)
def quittung_comit(body: QuittungCommitPostRequest = None):
    """
    Finishs a collection of data and finalizes receipt. Use this method after collecting all data via quittung/prepare
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/create',
    description=""" Creates a full featured receipt (Quittung) for an energy delivery as it appears on a charging session or similar events. Allows to embed receipt generation directly into external services.
 """,
    tags=['receipt_data_management'],
)
def quittung_create(body: QuittungCreatePostRequest):
    """
    Create a receipt for an energy delivery (only valid in Germany).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/prepare',
    description=""" During the first call an account parameter will be returned within the result object. Any other parameter will be set inside the preperation. If account is put into body/request in following requests, the existing collection will be extended/updated with the provided body parameters/values.
 """,
    tags=['receipt_data_management'],
)
def quittung_prepare(body: QuittungPreparePostRequest = None):
    """
    Allows to collect data with several requests (or a single) for a receipt.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/tse',
    description=""" Allows to retrieve all relevant data assiciated to a TSE service call. E.q. Input parameters, public key and signature.
 """,
    tags=['receipt_data_management', 'smart_meter_operations'],
)
def quittung_t_s_e(account: Optional[str] = None):
    """
    Retrieve TSE (Technische Sicherheitseinrichtung) Data for a given receipt (Strom-Quittung).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/tsedata',
    description=""" Allows to retrieve input string for a signing process.
 """,
    tags=['receipt_data_management', 'smart_meter_operations'],
)
def quittung_t_s_e_data(account: Optional[str] = None):
    """
    Retrieve TSE (Technische Sicherheitseinrichtung) raw data  only for a given receipt (Strom-Quittung).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/quittung/tsesignature',
    description=""" Allows to retrieve digital signature for a given receipt.
 """,
    tags=['receipt_data_management'],
)
def quittung_t_s_esignature(account: Optional[str] = None):
    """
    Retrieve TSE (Technische Sicherheitseinrichtung) Signature only for a given receipt (Strom-Quittung).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/quittung/zugferd',
    description=""" Allows to retrieve XML of the zugferd invoice.
 """,
    tags=['receipt_data_management'],
)
def quittung_zugferd(account: Optional[str] = None):
    """
    Retrieve Zugferd XML for a given receipt (Strom-Quittung).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stromkonto/balances',
    description=""" Stromkonto represents a core component of the Corrently Ecosystem. It is a ledger for green energy related transactions and gets heavily used by the public Web-UI on www.stromkonto.net . Beside of some decoration and reformating operations all data is backed by the [Energychain blockchain](https://github.com/energychain/) to provide consensus of balances and transactions. Use this API Endppoint if you prefere not to work with low level Distributed Ledger Technology (Blockchain).
 """,
    tags=['stromkonto_account_services'],
)
def stromkonto_balances(account: Optional[str] = None):
    """
    Balances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stromkonto/choices',
    description=""" Signable choices (contract changes) for customer.
 """,
    tags=['stromkonto_account_services', 'receipt_data_management'],
)
def stromkonto_choices(account: Optional[str] = None):
    """
    Selectable Choices for customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stromkonto/login',
    description=""" Sends a mail to a given email address to login this user. This function makes life a bit easier in order to not having to deal with private key protection on the user side as a shared key is used to sign transactions onbehalf of a particular account.  However viewing consensus information (balances) are public and *might move* from account to account without prior notification. Best practice for third party uses is to always start a session with the login RESP call and only create a user in case the response indicates an `unregistered` status.
 """,
    tags=['stromkonto_account_services'],
)
def stromkonto_login(body: StromkontoLoginPostRequest):
    """
    Login (via Mail)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stromkonto/prepareTransaction',
    description=""" Prepares and inques a transaction (transfer) between two accounts (Stromkonten). This might be used to send any balanced entity. Using this endpoint will only prepare the transaction and enques it for signing and countersigning. This is done from within the user UI using validation process. Note: This API method does not validate any transations. In other words authentication, authorization, validation and actual transfer of value is done using a smart contract during processing in the energy blockchain.
 """,
    tags=['stromkonto_account_services', 'receipt_data_management'],
)
def prepare_transaction(body: StromkontoPrepareTransactionPostRequest):
    """
    Prepare Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stromkonto/register',
    description=""" Calling this method with an unregistered (new) email will create a new account (Stromkonto) with all balances having a value of `0` and no transaction history. In addition some basic properties like region and zipcode are set to allow further operation of account.
 """,
    tags=['stromkonto_account_services'],
)
def stromkonto_register(body: StromkontoRegisterPostRequest):
    """
    Register (new Stromkonto)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tariff/components',
    description=""" Provides insides into the different cost components of energy for a private household.
Sample Request: https://api.corrently.io/v2.0/tariff/components?email=demo%40corrently.io&zip=69168&kwha=3300
 """,
    tags=['energy_tariff_info_management'],
)
def tariffcomponents(
    zipcode: Optional[str] = None,
    email: Optional[str] = None,
    kwha: Optional[int] = None,
    milliseconds: Optional[int] = None,
    wh: Optional[int] = None,
):
    """
    Energy Tariff price components
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tariff/slph0',
    description=""" Provides pricing data for private households with standard load profiles (Standardlastprofil H0).
 """,
    tags=['energy_tariff_info_management'],
)
def tariff_s_l_p_h0(zipcode: Optional[str] = None):
    """
    Energy Tariff information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wim/status',
    description=""" Access to status information of an existing metering change and allocation process.
 """,
    tags=['wim_process_information'],
)
def wimstatus(vid: Optional[str] = None):
    """
    WiM Proess Informtion
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
